---
title: "Unityのオンラインゲームの設計でMVPパターンを使う？"
emoji: "🕌"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: [unity, mvp, csharp, 個人開発, オンラインゲーム]
published: false
publication_name: midra_lab
---
## はじめに
今回は個人的にUnityのオンラインゲームの設計でMVPパターンを適応してみたので、それについてまとめてみたいと思います。
筆者自身はこういった設計論に関してはまだまだ勉強不足なので、間違っているところがあればご指摘いただけると幸いです。

## MVPパターンとは
> MVPパターンとは、ざっくり言うとModel(データ)、View(表示)、
> Presenter(両者の仲介役)という役割に分割して処理を行おうという考え方のことです。
> これは特に何かしらのデータをユーザーに表示する場面で役に立ちます。
> [引用元](https://virtualcast.jp/blog/2019/11/mvp_pattern_on_unity/#:~:text=MVP%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3%E3%81%A8%E3%81%AF,%E3%81%99%E3%82%8B%E5%A0%B4%E9%9D%A2%E3%81%A7%E5%BD%B9%E3%81%AB%E7%AB%8B%E3%81%A1%E3%81%BE%E3%81%99%E3%80%82)

## サンプルプロジェクト
[サンプルプロジェクト](https://github.com/eiei114/FishNetSample)

## 利用するライブラリ
- [UniRx](https://github.com/neuecc/UniRx)
- [UniTask](https://github.com/Cysharp/UniTask)
- [FishNet](https://github.com/FirstGearGames/FishNet)

## ネットワークモデルの選定
Client-Server型/専用サーバー型というものを選択します。

### Client-Server型/専用サーバー型とは
![189012203-ecee4a32-1ab0-4b19-9aa6-85a484d51032.png](/images/4a28a2774816cb/client_server.png)
#### 利点
- クライアントとサーバー間のみの接続状況を意識するだけでよい
- サーバーの負荷分散を適切に行ったり、スペックを上げることでスケールすることができる
- サーバー内でゲームロジックを完結するので安定したプレイ環境を得られる
- サーバー内でゲームロジックを完結するのでチート耐性がある。(クライアント側でチートを行われることが多い)

#### 欠点
- サーバー内でゲームロジックを完結するので処理コストが上がる

etc...

## その他前書き
今回はネットワーク通信を行うために[FishNet](https://github.com/FirstGearGames/FishNet)を利用しています。
こちらのライブラリは,[Mirror](https://github.com/MirrorNetworking/Mirror)というUnityの古参ネットワークライブラリをベースになっているものになります。
今回はクライアントホストにも対応しているためサーバー側のプロジェクトとクライアント側のプロジェクトを統合しています。

## 設計の全体像
![client_server.png](/images/4a28a2774816cb/Architecture_all.png)
※今回はサーバー側とクライアント側のプロジェクトは統合してあるため`ServerPlayerクラス`と`ClientPlayerクラス`は同じクラスです。区別しやすくするために名前を一時的に変更しています。

## 意識したこと
ネットワークのライブラリが依存しているのは`Network`ノードのみとなっています。
こうすることで以下の点が容易になると考えました。
- ネットワークのライブラリを変更する際に、他のノードに影響が出ない
- ロジック、ネットワーク、クライアントでそれぞれのバグ修正、機能追加が容易になる
- 作業分担の切り分けが容易になる

## クライアント側の各ノードについて解説
![client.jpg](/images/4a28a2774816cb/client.jpg)

#### Core
```
    public class PlayerModel : MonoBehaviour, IPlayerModelMutable
    {
        [SerializeField] private string _name;
        private IAsyncReactiveProperty<int> _score;
        
        private CancellationToken _token;

        public string Name => _name;
        public IReadOnlyAsyncReactiveProperty<int> Score => _score.ToReadOnlyAsyncReactiveProperty(_token);

        private void Awake()
        {
            _token = this.GetCancellationTokenOnDestroy();
        }

        public void SetName(string name)
        {
            _name = name;
        }

        public void IncrementScore()
        {
            _score.Value++;
        }

        public void DecrementScore()
        {
            _score.Value--;
        }

        public void Disconnect()
        { 
            Destroy(gameObject);
        }
    }
```

#### Network

```
    public class NetworkPlayerModel : NetworkBehaviour, INetworkPlayerModel, IPlayerModelCommand
    {
        private IPlayerModelMutable _serverModel;
        private PlayerView _playerView;
        private IPlayerModelQuery _clientModelQuery;

        private CancellationToken _token;
        
        [SerializeField] private PlayerModel _playerModel;

        private void Awake()
        {
            _token = this.GetCancellationTokenOnDestroy();
        }

        [Server]
        public void InitServer(string name)
        {
            Debug.Log($"Init Server Side {OwnerId}");
            _serverModel = _playerModel;
            _serverModel.SetName(name);

            new PlayerModelNetworkSender(_serverModel, this).AddTo(this);
        }

        public override async void OnStartClient()
        {
            base.OnStartClient();
            Debug.Log($"Init Client Side {OwnerId}");
            //クライアントサイドからセーバー上にあるモデルにアクセスできないようにする。
            if (IsClientOnly)
            {
                ((MonoBehaviour)_serverModel).enabled = false;
            }

            //仮想モデルを生成
            _clientModelQuery = new PlayerModelNetworkReceiver(this);

            //プレイヤービューを取得するまで待つ。
            await UniTask.WaitUntil(() => _playerView = FindObjectOfType<PlayerView>(), cancellationToken: _token);

            //view生成
            var view = _playerView.CreateView();
            //Presenter生成
            new PlayerPresenterClient(_clientModelQuery, view).AddTo(this);
        }

        public override void OnOwnershipClient(NetworkConnection prevOwner)
        {
            base.OnOwnershipClient(prevOwner);

            Debug.Log($"Init Owner Side {OwnerId}");

            new PlayerPresenterLocal(_serverModel, _playerView);
        }

        #region SyncVar

        [field: SyncVar()] public string SyncName { get; set; } = "";
        [field: SyncVar()] public int SyncScore { get; set; } = 0;

        #endregion

        #region ServerRpc

        [ServerRpc]
        public void IncrementScore()
        {
            _serverModel.IncrementScore();
        }

        [ServerRpc]
        public void DecrementScore()
        {
            _serverModel.DecrementScore();
        }

        [ServerRpc]
        public void Disconnect()
        {
            NetworkObject.Despawn();
            _serverModel.Disconnect();
        }

        #endregion
    }

```
### Presenter

```
    public class PlayerPresenterClient : IDisposable
    {
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();

        public PlayerPresenterClient(IPlayerModelQuery model, IPlayerQueryView view)
        {
            view.Name = model.Name;

            model.Score
                .Subscribe(value => { view.Score = value; }).AddTo(_cts.Token);
        }

        public void Dispose()
        {
            _cts.Cancel();
            _cts.Dispose();
        }
    }
```

```
    public class PlayerPresenterLocal : IDisposable
    {
        private readonly CompositeDisposable _compositeDisposable = new CompositeDisposable();
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();

        public PlayerPresenterLocal(IPlayerModelCommand model, IPlayerView view)
        {
            view.OnInitialized(_cts.Token);

            view.OnScoreObservable.Where(x => x == ScoreEnum.Increment)
                .Subscribe(_ => model.IncrementScore()).AddTo(_compositeDisposable);

            view.OnScoreObservable.Where(x => x == ScoreEnum.Decrement)
                .Subscribe(_ => model.DecrementScore()).AddTo(_compositeDisposable);
        }

        public void Dispose()
        {
            _compositeDisposable?.Dispose();
            _cts?.Cancel();
            _cts?.Dispose();
        }
    }
```

### View
- ネットワークのライブラリを利用してネットワーク通信を行うノードです。
- ライブラリを用いて変数の同期やRPCの実行を行います。

```
    public class PlayerView : MonoBehaviour, IPlayerView
    {
        [SerializeField] private Button AddButton;
        [SerializeField] private Button RemoveButton;

        [SerializeField] private Transform NameBoxList;
        [SerializeField] private PlayerBox NameBoxPrefab;

        private readonly Subject<ScoreEnum> _onScored = new Subject<ScoreEnum>();
        private readonly Subject<Unit> _onDisconnected = new Subject<Unit>();

        public IObservable<ScoreEnum> OnScoreObservable => _onScored;
        public IObservable<Unit> OnDisconnectObservable => _onDisconnected;
        
        public async UniTask OnInitialized(CancellationToken token)
        {
            AddButton.OnClickAsObservable().Subscribe(_ => _onScored.OnNext(ScoreEnum.Increment)).AddTo(this);
            RemoveButton.OnClickAsObservable().Subscribe(_ => _onScored.OnNext(ScoreEnum.Decrement)).AddTo(this);
        }

        public IPlayerQueryView CreateView()
        {
            var box = Instantiate(NameBoxPrefab, NameBoxList);
            return box;
        }
```

```
    public class PlayerBox : MonoBehaviour, IPlayerQueryView
    {
        [SerializeField] private Text NameText;
        [SerializeField] private Text ScoreText;

        public string Name
        {
            set => NameText.text = value;
        }

        public int Score
        {
            set => ScoreText.text = value.ToString();
        }
    }
```



